# 專案全面檢視與改善建議

## 一、當前問題分析

### 1.1 出牌後無回應的問題

**問題描述**：
從日誌分析，Player 3 出牌後，`nextTurn()` 被調用，`currentPlayerIndex` 從 3 變成 0，但沒有看到 Player 0 摸牌的日誌。

**可能原因**：
1. `startTurn()` 可能因為 `isFirstTurn` 標記而提前返回
2. `startTurn()` 執行時發生異常但被吞沒
3. 日誌沒有正確輸出

**已添加的調試日誌**：
- 在 `startTurn()` 開始時添加日誌，記錄 `currentPlayerIndex` 和 `isFirstTurn` 的值
- 在摸牌前添加日誌

### 1.2 代碼複雜度問題

**WebSocketGameSession 類別**：
- 目前約 886 行，單一類別過於龐大
- 職責過多：遊戲流程控制、動作處理、狀態同步、訊息廣播等
- WMC（循環複雜度）估計超過 50，超過建議值（15-20）

### 1.3 狀態管理問題

**問題點**：
1. `currentPlayerIndex` 在多個地方被修改，容易出現不一致
2. `waitingForAction` 狀態管理複雜，容易出現競態條件
3. `isFirstTurn` 標記可能在某些情況下沒有正確重置

### 1.4 同步問題

**問題點**：
- 雖然方法使用了 `synchronized`，但 WebSocket 處理是異步的
- 多個線程可能同時處理不同的玩家請求
- `broadcastState()` 可能在狀態不一致時被調用

## 二、架構問題分析

### 2.1 類別職責不清

**WebSocketGameSession 當前職責**：
1. ✅ 遊戲會話管理（應該保留）
2. ✅ 玩家連接管理（應該保留）
3. ⚠️ 遊戲流程控制（應該提取）
4. ⚠️ 動作處理邏輯（應該提取）
5. ⚠️ 狀態同步（應該提取）
6. ⚠️ 訊息廣播（可以保留但需要簡化）

### 2.2 缺少抽象層

**問題**：
- 沒有明確的遊戲狀態機
- 動作處理邏輯散落在多個方法中
- 缺少統一的錯誤處理機制

### 2.3 測試覆蓋率問題

**問題**：
- 缺少整合測試
- 單元測試可能沒有覆蓋所有分支
- 難以測試複雜的遊戲流程

## 三、改善建議

### 3.1 短期修復（立即執行）

#### 3.1.1 修復 startTurn() 問題

**建議**：
1. 添加詳細日誌追蹤 `startTurn()` 的執行
2. 確認 `isFirstTurn` 標記的設置和重置邏輯
3. 檢查是否有異常被吞沒

**實作**：
```java
private void startTurn() {
    logger.debug("startTurn called: currentPlayerIndex = {}, isFirstTurn = {}", 
        currentPlayerIndex, isFirstTurn);
    
    // 檢查並重置 isFirstTurn
    if (currentPlayerIndex == 0 && isFirstTurn) {
        logger.debug("Skipping first turn for dealer");
        isFirstTurn = false;
        // 提示莊家出牌
        Map<String, Object> msg = new HashMap<>();
        msg.put("message", "莊家請出牌");
        send(players.get(0), new Packet(Command.GAME_UPDATE, msg));
        return;
    }
    
    // 摸牌邏輯...
}
```

#### 3.1.2 統一狀態管理

**建議**：
1. 創建狀態管理類別，統一管理遊戲狀態
2. 使用狀態模式（State Pattern）管理遊戲流程
3. 添加狀態驗證方法

### 3.2 中期重構（建議執行）

#### 3.2.1 提取遊戲流程管理

**建議**：創建 `GameFlowManager` 類別

**職責**：
- 管理遊戲流程（開始、回合、結束）
- 處理回合切換邏輯
- 管理 `currentPlayerIndex` 和 `isFirstTurn`

**優點**：
- 降低 `WebSocketGameSession` 的複雜度
- 更容易測試遊戲流程邏輯
- 更容易維護

#### 3.2.2 提取動作處理邏輯

**建議**：創建 `ActionHandler` 類別

**職責**：
- 處理所有動作（吃、碰、槓、胡）
- 管理動作優先級
- 處理動作回應

**優點**：
- 動作處理邏輯集中管理
- 更容易添加新的動作類型
- 更容易測試

#### 3.2.3 提取狀態同步邏輯

**建議**：創建 `StateManager` 類別

**職責**：
- 管理遊戲狀態的同步
- 處理 `broadcastState()` 邏輯
- 管理玩家視圖的構建

**優點**：
- 狀態同步邏輯集中管理
- 更容易優化狀態更新
- 更容易添加狀態快照功能

### 3.3 長期改善（可選執行）

#### 3.3.1 引入遊戲狀態機

**建議**：使用狀態機模式管理遊戲狀態

**狀態**：
- `INITIALIZING`：初始化
- `PLAYING`：進行中
- `WAITING_FOR_ACTION`：等待動作
- `GAME_OVER`：遊戲結束

**優點**：
- 狀態轉換明確
- 不容易出現非法狀態
- 更容易調試

#### 3.3.2 引入事件系統

**建議**：使用事件驅動架構

**事件類型**：
- `TileDrawnEvent`：摸牌事件
- `TileDiscardedEvent`：出牌事件
- `ActionPerformedEvent`：動作執行事件
- `GameStateChangedEvent`：遊戲狀態變更事件

**優點**：
- 解耦遊戲邏輯
- 更容易添加新功能（如回放、統計）
- 更容易測試

#### 3.3.3 改進錯誤處理

**建議**：
1. 創建統一的異常類別
2. 使用異常處理器統一處理錯誤
3. 添加錯誤恢復機制

## 四、代碼品質改善

### 4.1 日誌系統

**當前狀態**：✅ 已引入 SLF4J + Logback

**建議**：
- 保持當前實現
- 考慮添加結構化日誌（使用 MDC）
- 考慮添加性能監控日誌

### 4.2 測試覆蓋率

**建議**：
1. 為關鍵邏輯添加單元測試
2. 添加整合測試覆蓋完整遊戲流程
3. 使用 Mock 對象測試複雜場景

### 4.3 文檔

**建議**：
1. 為複雜方法添加 JavaDoc
2. 創建架構文檔
3. 創建 API 文檔

## 五、具體重構建議

### 5.1 建議的重構順序

1. **第一步**：修復當前 bug（`startTurn()` 問題）
2. **第二步**：提取 `GameFlowManager`
3. **第三步**：提取 `ActionHandler`
4. **第四步**：提取 `StateManager`
5. **第五步**：引入狀態機（可選）

### 5.2 重構後的類別結構

```
WebSocketGameSession (主控制器, ~200行)
    ├── GameFlowManager (遊戲流程, ~150行)
    ├── ActionHandler (動作處理, ~200行)
    ├── StateManager (狀態同步, ~100行)
    └── MessageBroadcaster (訊息廣播, ~50行)
```

## 六、當前 Bug 的修復方案

### 6.1 問題根源分析

從日誌看，`startTurn()` 可能因為以下原因沒有執行：
1. `isFirstTurn` 仍然是 `true`（不太可能，因為已經進行了很多輪）
2. `startTurn()` 執行時發生異常
3. 日誌沒有正確輸出

### 6.2 修復步驟

1. **添加詳細日誌**（已完成）
2. **檢查 `isFirstTurn` 的重置邏輯**
3. **檢查異常處理**
4. **確認 `startTurn()` 是否真的被調用**

### 6.3 建議的代碼修改

```java
private void startTurn() {
    try {
        logger.debug("startTurn called: currentPlayerIndex = {}, isFirstTurn = {}", 
            currentPlayerIndex, isFirstTurn);
        
        // 檢查並重置 isFirstTurn
        if (currentPlayerIndex == 0 && isFirstTurn) {
            logger.debug("Skipping first turn for dealer");
            isFirstTurn = false;
            // 明確提示莊家出牌
            Map<String, Object> msg = new HashMap<>();
            msg.put("message", "莊家請出牌");
            send(players.get(0), new Packet(Command.GAME_UPDATE, msg));
            return;
        }
        
        // Draw tile for current player
        logger.debug("Drawing tile for Player {}", currentPlayerIndex);
        Tile drawn = engine.drawTile();
        
        if (drawn == null) {
            logger.warn("Wall is empty, game should end");
            Map<String, Object> data = new HashMap<>();
            data.put("message", "Game Over - Wall Empty!");
            broadcast(new Packet(Command.GAME_OVER, data));
            return;
        }

        PlayerHand finalHand = hands.get(currentPlayerIndex);
        finalHand.addTile(drawn);
        logger.debug("Player {} drew tile {}, hand size now: {}", 
            currentPlayerIndex, drawn, finalHand.getTileCount());

        // Notify everyone
        broadcastState();

        // Send specific "You Drew X" message
        Map<String, Object> drawMsg = new HashMap<>();
        drawMsg.put("action", "DRAW");
        drawMsg.put("tile", drawn.toString());
        send(players.get(currentPlayerIndex), new Packet(Command.GAME_UPDATE, drawMsg));

        logger.info("Turn: Player {} drew {}", currentPlayerIndex, drawn);

        // ... 後續邏輯
    } catch (Exception e) {
        logger.error("Error in startTurn for Player {}", currentPlayerIndex, e);
        // 錯誤處理
    }
}
```

## 七、優先級建議

### 高優先級（立即執行）
1. ✅ 修復 `startTurn()` 問題
2. ✅ 添加詳細日誌
3. ✅ 統一錯誤處理

### 中優先級（近期執行）
1. 提取 `GameFlowManager`
2. 提取 `ActionHandler`
3. 改進狀態管理

### 低優先級（長期規劃）
1. 引入狀態機
2. 引入事件系統
3. 性能優化

## 八、測試建議

### 8.1 單元測試
- 測試 `startTurn()` 的各種情況
- 測試 `nextTurn()` 的邏輯
- 測試 `performChow()`、`performPong()` 等動作處理

### 8.2 整合測試
- 測試完整遊戲流程
- 測試多輪遊戲
- 測試異常情況處理

### 8.3 壓力測試
- 測試多個並發連接
- 測試快速操作
- 測試網路斷線恢復

## 九、當前 Bug 的深度分析

### 9.1 問題症狀

從最新的日誌分析（zsh 91-243）：
1. Player 3 出牌後，`nextTurn()` 被調用
2. `currentPlayerIndex` 從 3 變成 0
3. **但沒有看到 `startTurn()` 被調用的日誌**

### 9.2 可能原因

#### 原因 1: `startTurn()` 沒有被調用（不太可能）
- `nextTurn()` 最後一行明確調用 `startTurn()`
- 除非有異常發生，否則應該會被調用

#### 原因 2: `startTurn()` 被調用但提前返回
- 如果 `currentPlayerIndex == 0 && isFirstTurn`，會提前返回
- 但 `isFirstTurn` 應該在遊戲開始後的第一輪就被設置為 `false`

#### 原因 3: `startTurn()` 執行時發生異常
- 異常可能被吞沒
- 需要檢查是否有 try-catch 吞沒了異常

### 9.3 修復方案

#### 方案 1: 添加異常處理和日誌

```java
private void nextTurn() {
    try {
        logger.debug("nextTurn called: currentPlayerIndex before = {}", currentPlayerIndex);
        currentPlayerIndex = (currentPlayerIndex + 1) % 4;
        logger.debug("nextTurn: currentPlayerIndex after = {}", currentPlayerIndex);
        startTurn();
    } catch (Exception e) {
        logger.error("Error in nextTurn", e);
        // 錯誤處理
    }
}

private void startTurn() {
    try {
        logger.debug("startTurn called: currentPlayerIndex = {}, isFirstTurn = {}", 
            currentPlayerIndex, isFirstTurn);
        
        // ✅ P0-1: 如果是莊家第一輪，跳過摸牌
        if (currentPlayerIndex == 0 && isFirstTurn) {
            logger.debug("Skipping first turn for dealer");
            isFirstTurn = false;
            // 明確提示莊家出牌
            Map<String, Object> msg = new HashMap<>();
            msg.put("message", "莊家請出牌");
            send(players.get(0), new Packet(Command.GAME_UPDATE, msg));
            return;
        }
        
        // Draw tile for current player
        logger.debug("Drawing tile for Player {}", currentPlayerIndex);
        Tile drawn = engine.drawTile();
        
        if (drawn == null) {
            logger.warn("Wall is empty, game should end");
            Map<String, Object> data = new HashMap<>();
            data.put("message", "Game Over - Wall Empty!");
            broadcast(new Packet(Command.GAME_OVER, data));
            return;
        }

        PlayerHand finalHand = hands.get(currentPlayerIndex);
        finalHand.addTile(drawn);
        logger.debug("Player {} drew tile {}, hand size now: {}", 
            currentPlayerIndex, drawn, finalHand.getTileCount());

        // Notify everyone
        broadcastState();

        // Send specific "You Drew X" message
        Map<String, Object> drawMsg = new HashMap<>();
        drawMsg.put("action", "DRAW");
        drawMsg.put("tile", drawn.toString());
        send(players.get(currentPlayerIndex), new Packet(Command.GAME_UPDATE, drawMsg));

        logger.info("Turn: Player {} drew {}", currentPlayerIndex, drawn);

        // ... 後續邏輯
    } catch (Exception e) {
        logger.error("Error in startTurn for Player {}", currentPlayerIndex, e);
        // 錯誤恢復：嘗試繼續遊戲
        broadcastMessage("System", "Error in turn, trying to recover...");
    }
}
```

#### 方案 2: 檢查 `isFirstTurn` 的重置邏輯

**問題**：`isFirstTurn` 只在 `startTurn()` 中被重置，但如果 `startTurn()` 因為某些原因沒有執行，`isFirstTurn` 可能一直是 `true`。

**修復**：在 `start()` 方法中，當莊家第一輪結束後，明確重置 `isFirstTurn`：

```java
// 在莊家出牌後，明確重置 isFirstTurn
// 或者在 startTurn() 中，除了檢查 isFirstTurn，還要檢查是否真的需要跳過
```

#### 方案 3: 使用狀態機

**長期方案**：引入狀態機來管理遊戲狀態，避免依賴 `isFirstTurn` 這種標記。

### 9.4 立即執行的修復

1. **添加詳細日誌**（已完成）
2. **添加異常處理**
3. **檢查 `isFirstTurn` 的重置時機**
4. **添加狀態驗證**

## 十、總結

### 10.1 當前專案的主要問題

1. **單一類別過於龐大**：`WebSocketGameSession`（886行）承擔了過多職責
2. **狀態管理複雜**：多個狀態變量（`currentPlayerIndex`, `waitingForAction`, `isFirstTurn` 等）容易出現不一致
3. **缺少抽象層**：遊戲邏輯和網路邏輯混在一起
4. **錯誤處理不足**：異常可能被吞沒，缺少統一的錯誤處理機制
5. **測試覆蓋不足**：缺少完整的整合測試

### 10.2 建議的重構方向

1. **分層架構**：將遊戲邏輯、網路邏輯、狀態管理分開
2. **職責單一**：每個類別只負責一個明確的職責
3. **易於測試**：設計要便於單元測試和整合測試
4. **狀態管理**：使用狀態機或明確的狀態管理類別
5. **錯誤處理**：統一的錯誤處理機制

### 10.3 建議的重構步驟

1. **第一步**：修復當前 bug（`startTurn()` 問題）
   - 添加詳細日誌
   - 添加異常處理
   - 驗證狀態一致性

2. **第二步**：提取職責到新類別
   - `GameFlowManager`：管理遊戲流程
   - `ActionHandler`：處理動作
   - `StateManager`：管理狀態

3. **第三步**：改進錯誤處理
   - 統一異常類別
   - 錯誤恢復機制
   - 錯誤日誌記錄

4. **第四步**：添加測試
   - 單元測試
   - 整合測試
   - 壓力測試

### 10.4 優先級建議

**高優先級（立即執行）**：
1. ✅ 修復 `startTurn()` 問題
2. ✅ 添加詳細日誌和異常處理
3. ✅ 驗證狀態一致性

**中優先級（近期執行）**：
1. 提取 `GameFlowManager`
2. 提取 `ActionHandler`
3. 改進狀態管理

**低優先級（長期規劃）**：
1. 引入狀態機
2. 引入事件系統
3. 性能優化

